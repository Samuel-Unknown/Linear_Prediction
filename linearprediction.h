#ifndef LINEARPREDICTION_H
#define LINEARPREDICTION_H
#include <matrices.h>
/*
* имеем в начале уравнение y = sin(x);
* имеем точку N и точку M, до M все y(x) известны.
* на самом деле ещё имеем точку от которой считаем иксы, но я взял её нулём, так проще..
* по этому уравнению заполняем матрицу [J] (размерность её M-N строк на N столбцов) игриками так,
* что в первой строке у нас y1, y2, y3,...yn (короче все точки от 0 до N)
* во второй строке y2, y3,...y_n+1
* и так далее M-N строк
* заполняем матрицу [b] (размерность M-N строк на 1 столбец) значениями y_N+1, y_N+2, ..., y_M
* ИСХОДНАЯ система УРАВНЕНИЙ записывается так
*               [J]*[a] = [b]
* где [а] - это неизвестные коэффициенты
* что бы решить эту штуку используем уравнение
*               [J]^tr * [J] * [a] = [J] ^tr * [b]
* перепишем это уравнение
                             [A] * [a] = [B]
* это систему линейных уравнение решаем методом Жордана-Гаусса ибо теперь матрица [A] квадратная
* таким образом нашли все неизвестные a матрицы-столбца [a]
* строим точки от N до M используя эти коэффициенты так
*           y_N+1 = a1 * y1 + a2 * y2 + ... + a_N * y_N;
*           y_N+2 = a1 * y2 + a2 * y3 + ... + a_N * y_N+1;
 * и так далее до y_M
*/

class linearPrediction
{
public:
    linearPrediction();
    double myFun(double x); // функция которую будем предсказывать
    int N, M;
    Matrix _J;  // прямоугольная матрица (переопределённая)
    Matrix _a;  // будет хранить решение
    Matrix _b;  // известные значения y от точки N до M которые хотим предсказать
    // [_A] * [_a] = [_B]
    Matrix _A; // _J(транспонированная) * _J
    Matrix _B; // _J(транспонированная) * _b
    Matrix Gaus_Jordan_Method(Matrix A, Matrix B);
    Matrix prediction();  // возвращает матрицу координат (y) предсказанных точек
    double step; // шаг по иксам
};

#endif // LINEARPREDICTION_H
